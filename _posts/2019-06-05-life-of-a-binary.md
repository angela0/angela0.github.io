---
layout: post
title:  "一个二进制的一生"
start: 2019-06-03
uuid: 225544563661483260620351555119652899572
published: false
categories:
- Translate
tag:
- Linux
- Compiler
---

几乎你们每个人都编写过一个程序，编译然后运行它以查看你辛苦劳动的成果。最终看到你的程序正常工作感觉很好，不是吗？但为了使所有这一切工作，我们还要感谢其他人。还有就是你的编译器（当然，假设你使用的是编译型语言，而不是解释型语言），它也在幕后做了很多工作。

在本文中，我将尝试向你展示你编写的源代码如何转换为你机器实际能运行的东东。我选择 Linux 系统以及 C 编程语言，但这里的概念可以应用于许多编译语言。

<!-- more -->

**注意：**如果你想跟随文章进行操作，你需要安装 **gcc** 和 **elfutils**。

让我们从一个简单的 C 程序开始，看看编译器如何转换成二进制的。

<script src="https://gist.github.com/kishuagarwal/1a2313f8a3b4c2f6d77650a13e2e35ca.js"></script>

这个程序创建了两个变量，将它们相加并在屏幕上打印结果。很简单，对吧？

但是，让我们看看这个看似简单的程序必须经历什么才能最终在你的系统上执行。

编译器通常有五大步（最后一步实际上是操作系统做的）：

![](/assets/img/225544563661483260620351555119652899572/0.svg)

让我们详细地了解下每一步吧。

![](/assets/img/225544563661483260620351555119652899572/1.svg)

第一步是**预处理（Preprocessing）**，它由预处理器完成。预处理器处理你的代码中的所有预处理指令。这些指令都是以 *#* 开头的。但在处理之前，它会先移除注释，因为这是给人读的。然后找到所有的 *#* 指令，执行指令内容。

在上面的代码中，我们刚刚使用了 **#include** 指令，它简单地告诉预处理器复制 **stdio.h** 文件到此文件中的当前位置。

你可以使用 **gcc** 的 **-E** 标志来查看预处理器的输出。

```
gcc -E sample.c
```

结果类似下面这样：

<script src="https://gist.github.com/kishuagarwal/f2ce4e82094096bf318a1652a66613c2.js"></script>

![](/assets/img/225544563661483260620351555119652899572/2.svg)

可能让你感到困惑，第二步也叫编译。编译器拿到预处理器的输出，会进行下面这重要的几步：

- 把输出传递给词法分析器，以识别文件中存在的各种 token。token 就是程序中的字面，如 'int'，'return'，'void'，'0'等等。词法分析器还将每个 token 与其类型相关联，无论 token 是字符串常量、整数、浮点数还是 if 关键字等等。
- 把词法分析的输出传递给语法分析器，来检查程序是否符合语言的语法规则。例如在处理这行代码时会报语法错误：`b = a + ;`。因为 **+** 少了一个操作数。
- 把语法分析的输出传递给语义分析器，它会检查程序是否满足语言的语义，例如类型检查、变量在使用前声明等等。
- 如果程序在语义上是正确的，那么源代码将转换为指定目标架构的汇编指令。默认情况下，它为当前计算机生成汇编。但是假设你正在为嵌入式系统构建程序，那么你可以传递目标机器的架构，gcc将为该机器生成汇编。

要看这一步的输出，使用 **gcc** 的 **-S** 标志：

```
gcc -S sample.c
```

根据你的环境，可能生成类似下面的代码：

<script src="https://gist.github.com/kishuagarwal/0ec66d071d2fee84cf5792186dcf0a5d.js"></script>

如果你不懂汇编语言，猛一看似乎很可怕，但并没那么糟糕。理解汇编代码比普通高级语言代码需要更多的时间，但是如果有足够的时间，你肯定可以阅读它。

我们来看看这个文件包含的内容。

所有以一个 `.` 开头的行是汇编器指令。**.file** 表示源文件名，可以用作调试。源代码中的字符串常量 **%d\n** 被放在了 **.rodata** 段（ro 指只读，read-only），因为它是一个只读字符串。编译器给这个字符串命名为 **LC0**，方便以后在代码中引用。当你看到一个标签以 `.L` 开头，说明标签是当前文件本地的，对其它文件不可见。

**.globl** 说明 main 是一个全局符号，可以被其它文件调用。**.type** 指明了 main 是一个函数。下面就是 main 函数的汇编代码。你可以忽略以 **cfi** 开头的指令。它们用于在异常情况下展开调用堆栈。本文中我们将忽略它们，但你可以在[此处](https://sourceware.org/binutils/docs/as/CFI-directives.html)了解更多相关信息。

现在让我们试着理解下 main 函数的汇编代码吧。

![](/assets/img/225544563661483260620351555119652899572/3.svg)

**11 行**，你需要知道，当你调用函数时，会为该函数创建一个新的栈帧。为了实现这一点，我们需要一些方法来知道新函数返回时调用者的函数帧指针的位置。这就是我们将存储在 **rbp** 寄存器中的当前帧指针压入堆栈的原因。

**14 行**，将当前堆栈指针拷贝到基指针中。这就是我们当前的函数帧指针。图 1 描述了把 rbp 寄存器压入栈之前的状态，图 2 显示了在前一个帧指针被压入栈并将当前堆栈指针拷贝到当前帧指针之后的状态。

**16 行**，我们的程序中有 3 个局部变量，所有类型都是 int。在我的机器上，每个 int 占用 4 个字节，因此我们需要 12 个字节的空间来保存我们的局部变量。我们在堆栈上为局部变量创建空间的方式是将堆栈指针递减我们局部变量所需的字节数。减少是因为堆栈从较高地址增长到较低地址。但是在这里你看到我们减少了 16 而不是 12，原因是空间会被分配在 16个 字节的块中。因此，即使只有 1 个局部变量，也会在堆栈上分配 16 个字节的空间。这是出于某些架构的性能考虑。参见图 3，了解堆栈现在的布局。

**17-22 行**，这段代码很简单直接。编译器使用 **rbp-12** 存储变量 **a**，使用 **rbp-8** 存储 **b**，使用 **rbp-4** 存储 **c**。它将值 1 和 2 分别拷贝到变量 **a** 和 **b** 的地址。为准备加法运算，它将 **b** 的值先拷贝到 **edx** 寄存器，并将 **a** 的值拷贝到 **eax** 寄存器。相加的结果存储在 **eax** 寄存器中，该寄存器稍后被拷贝到 **c** 变量的地址。

**23-27 行**，然后我们准备 printf 调用。首先，将 **c** 的值拷贝到 **esi** 寄存器。然后我们的字符串常量 **％d\n** 的地址被拷贝到 **edi** 寄存器。**esi** 和 **edi** 寄存器现在保存了 **printf** 调用的参数。**edi**保存第一个参数，**esi**保存第二个参数。然后我们调用 **printf** 函数来打印类型为整型的变量 **c** 的值。这里要注意的是此时 **printf** 符号未定义。我们将在本文后面看到如何解析这个 **printf** 符号。

**.size** 表示 main 函数有多少字节。**.-main** 是一个表达式，其中的符号 `.` 指当前行的地址。所以这个表达式的意思是 **当前行的地址 - main 函数的地址**，也就是 main 函数有多少字节。

**.ident** 就是告诉汇编器把后面的东东加上 **.comment** 段。**.note.GNU-stack** 用于指示程序中的该栈是否是可执行的。大部分情况这个值是个空字符串，表明这个栈是不能执行的。

![](/assets/img/225544563661483260620351555119652899572/4.svg)

我们现在得到的是汇编程序，但它仍无法被处理器理解。我们必须将汇编语言转换为机器语言，这项工作由汇编程序完成。汇编程序拿到汇编文件并生成一个目标文件，该文件是包含程序机器指令的二进制文件。

让我们将汇编文件转换为目标文件，以查看当前过程。要获得程序的目标文件，使用 **gcc** 的 **-c** 标志：

```
gcc -c sample.c
```

你会得到一个扩展名为 **.o** 的目标文件。由于这是一个二进制文件，你将无法在普通文本编辑器中打开它来查看它的内容。但是我们可以使用工具来查找这些目标文件中的内容。目标文件有许多不同的文件格式。我们只关注 Linux 上使用的 [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) 文件格式。

ELF 文件包含以下信息：

- ELF 头部
- 程序头表
- 段头表
- 被前面表引用的其它数据

**ELF 头** 包含目标文件的元信息，如文件类型、生成二进制的机器、版本、头部大小等等。要查看头部信息，给 **eu-readelf** 工具一个 **-h** 标志：

<script src="https://gist.github.com/kishuagarwal/df3c04b51211ede7bddbb8324c0068df.js"></script>

从上面的列表中可以看到，没有任何**程序头部**，这并没什么问题。**程序头部**只在可执行文件或者共享库中。在我们下一步链接文件之后就能看到**程序头部**了。

但我们确实有 13 个段，使用 **-S** 标志让我们看看这些段：

<script src="https://gist.github.com/kishuagarwal/afeef93343641ee40de78fdff2ba48d2.js"></script>

你无需了解列表中的所有段。但实际上，对于每个段，它都列出了各种信息，例如段的名称，大小以及到文件开头的偏移量。我们使用的几个重要的段如下：

- **text** 段包含了我们的机器码
- **rodata** 段包含程序中的只读数据。它可能是程序中使用的常量或者字符串字面量。就像这里的 **%d\n**
- **data** 段包含了程序中初始化的数据。这里是空的，因为我们没有任何初始化过的数据
- **bss** 段和 **data** 段类似，但包含的是未初始化的数据。未初始化的数据可能是像 **int arr[100]** 这样声明的一个数组，它就位于这个段。关于 bss 段要指出的一点是，不像其它段会根据内容占用空间，bss 段只有段大小，没别的东西了。因为在加载时，我们只需要知道这个段的大小就可以了。这样就能减小最终可执行文件的大小。
- **strtab** 段列出程序中所有的字符串
- **symtab** 段是符号表。它包含了程序中的所有符号（变量和函数名）
- **rela.text** 段是重定位段。后面会详细讲

你还可以查看这些段的内容，只需将相应的段号传递给 **eu-readelf** 程序。你还可以使用 **objdump** 工具。它还可以为你提供某些段的反汇编。

让我们更详细地谈谈 **rela.text** 段。记住我们在程序中使用的 **printf** 函数。现在，**printf** 是我们自己没有定义的东西，它是 C 库的一部分。通常，当你编译 C 程序时，编译器以某种方式编译它们，以便你调用的 C 函数不与可执行文件捆绑在一起，从而减少了最终可执行文件的大小。而所有这些符号组成一个叫做 **重定位表** 的表，会在之后由**装载器**填充。稍后我们将讨论有关**装载器**部分的更多内容，但是现在，重要的是如果你看一下 **rela.text** 段，你会发现那里列出了 **printf** 符号。让我们确认一下这里:

<script src="https://gist.github.com/kishuagarwal/4173bcae76d5b050523427617f45e5a7.js"></script>

你可以忽略第二个重定位段 **.rela.eh_frame**。它与异常处理有关，这对我们来说并不是很感兴趣。让我们看看第一个段。在那里我们可以看到两个条目，其中一个是我们的 **printf** 符号。此条目的含义是，此文件中使用的符号名称为 **printf** 但尚未定义，该符号位于此文件中，位于 **.text** 段偏移 0x31 处。让我们检查 **.text** 段中偏移量为 0x31 的内容：

<script src="https://gist.github.com/kishuagarwal/83cf53bbe21fa03faee61151105eb6f4.js"></script>

在这里，你可以看到偏移量 0x30 处的 call 指令。**e8** 代表 call 指令的操作码，后跟着的偏移量 0x31 到 0x34 的 4 个字节，这应该对应于我们现在没有的 printf 函数的实际地址，因此它们只是 00。（稍后，我们将看到位置实际上并不包含 printf 地址，而是使用名为 **plt** 表的东东间接调用它。稍后我们将介绍此部分）

![](/assets/img/225544563661483260620351555119652899572/5.svg)

到目前为止我们只使用了一个源文件。但实际上，这种情况很少。在实际的生产代码中，你需要编译数百个源代码文件来创建可执行文件。那之前的步骤在会有什么不同么？

前面的步骤都是一样的。所有源代码文件都将单独进行预处理、编译、汇编，最后我们将获得单独的目标代码文件。

每个源代码文件都不是孤立的。在某个文件中定义的一些函数、全局变量，会在其他文件中使用。

链接器的工作是聚集所有目标文件，遍历每个目标文件并跟踪每个文件定义的符号以及它使用的符号。它可以在每个目标文件的符号表中找到所有这些信息。收集所有信息后，链接器会创建一个目标文件，将每个单独目标文件中的所有段组合到新目标文件相应的段中，并重定位所有可以解析的符号。

在我们的例子中，我们只有一个文件，但由于我们使用 C 库中的 printf 函数，我们的源文件将动态链接到 C 库。现在让我们链接我们的程序并进一步查看输出。

```
gcc sample.c
```

我不会在这里详细介绍输出，因为它也是我们上面看到的一个 ELF 文件，只是有一些新的段。这里需要注意的一点是，当我们查看从汇编器中获得的目标文件时，我们看到的地址是相对的。但是在链接了所有文件后，我们已经知道相当多的信息了，因此，如果你查看这个阶段的输出，发现它包含绝对地址。

在此阶段，链接器已识别出我们程序中使用的所有符号，谁使用这些符号，以及谁定义了这些符号。链接器只是将符号定义处的地址映射到符号的使用处。但是在完成所有这些之后，仍然存在一些尚未解析的符号，其中一个是我们的 **printf** 符号。通常，这些符号是外部定义的变量或外部定义的函数。链接器还要创建一个重定位表，与汇编器创建的重定位表一样，这些条目仍未解析。

此时你应该知道，你使用的从其他库中的函数和数据可以静态链接或动态链接。静态链接意味着这些库中的函数和数据将被复制到你的可执行文件中。然而，如果你进行动态链接，那么这些函数和数据不会复制到可执行文件中，从而减少可执行文件大小。

具有动态链接功能的库必须是共享库（**so** 文件）。通常，许多程序使用的公共库都是共享库，我们使用的 libc 库就是。非常多的程序都使用 **libc**，如果每个程序都静态链接它，那么会有很多相同代码的副本占用你内存中的空间。动态链接可以解决这个问题，在任何时候只有一个 libc 副本占用内存空间，所有程序都引用该共享库中。

为了实现动态链接，链接器会额外创建两个段，它们在汇编器生成的目标代码中不存在。分别是 **.plt** 段（过程链接表/Procedure Linkage table）和 **.got** 段（全局偏移表/Global Offset Table）。当我们加载可执行文件时，我们会介绍这一部分，因为它们在实际加载可执行文件时有用。

![](/assets/img/225544563661483260620351555119652899572/6.svg)

现在是时候实际运行我们的可执行文件了。

当你单击 GUI 中的文件或从命令行运行它时，会间接地调用 **execev** 系统调用。正是这个系统调用，内核开始在内存中加载可执行文件。

请记住下面的 **程序头表（Program Header Table）**。这是非常有用的地方。

<script src="https://gist.github.com/kishuagarwal/a71434e035c88a6ca47f51fd92d7faee.js"></script>

内核怎么知道去哪找这个表呢？这个信息可以在 **ELF 头** 找到，而 **ELF 头** 位于文件开头。找到之后，内核会把类型为 **LOAD** 的条目加载到进程的内存空间。

从上面的列表中可以看到，有两个类型为 **LOAD** 的条目。你还可以看看每个 segment 都包含了哪些段。

现代操作系统和处理器使用页来管理内存。你的计算机内存分为固定大小的块，当任何进程请求一些内存时，操作系统会为该进程分配一些页。除了有效管理内存的好处之外，这还更具有安全性。操作系统和内核可以为每个页设置保护位。保护位指定某个页是否为只读，可以写入还是可以执行。保护位设置为只读的页无法修改，因此可防止有意或无意地修改数据。

只读页还有一个好处：同一程序的多个运行进程可以共享相同的页。由于页是只读的，因此没有正在运行的进程可以修改这些页，因此，每个进程都可以正常工作。

为了设置这些保护位，我们必须告诉内核，哪些页要标记为只读，哪些页可以写入和执行。这些信息存储在上面每个条目的 Flags 中。

注意第一个 **LOAD** 条目。它被标记为 R 和 E，这意味着这些段可以被读取和执行但不能被修改，如果你向下看可以看到哪些段在这个 segment 中，你可以看到两个熟悉的身影：**.text** 和 **.RODATA**。因此，我们的代码和只读数据只能被读取和执行，但不能被修改，就应该是这样。

类似的，第二个 **LOAD** 包含了初始化和未初始化的数据，**GOT** 表（后面详细讲）被标记为 RW，因此可以读写，但不能被执行。

加载这些 segment 并设置其权限后，内核会检查是否存在 **INTERP** segment。在静态链接的可执行文件中，不需要这个，因为可执行文件包含它需要的所有代码，但对于动态链接的可执行文件，它很重要。包含了 **.interp** 段，其中有动态链接器的路径。（查看通过 gcc 编译器的 **-static** 标志生成的可执行文件中的头表是否有 **INTERP**）

在我们的例子中，有一个 **INTERP**，它指向动态链接器 **/lib64/ld-linux-x86-64.so.2**。与我们的可执行文件类似，内核将通过读取头部，查找它的 segment 并将它们加载到当前程序的内存空间来加载这些共享对象。在静态链接的可执行文件中，所有这些都不需要，内核可以把控制权交给我们的程序，而这里内核把控制权交给动态链接器并把我们的 main 函数的地址压入堆栈，以便在动态链接器之后完成它的工作，知道将控制权交给哪里。

我们现在应该理解一下已经跳过太久的两个表，**过程链接表（Procedure Linkage Table）** 和 **全局偏移表（Global Offset Table）**，因为它们与动态链接器的功能密切相关。

你的程序可能需要两种类型的重定位。变量重定位和函数重定位。对于外部定义的变量，我们在 **GOT** 表中包含该条目，而在外部定义的函数中在这两个表中都有。因此，从本质上讲，**GOT** 表包含所有外部定义的变量和函数的条目，**PLT** 表只有函数的条目。使用两个函数表的原因将通过以下示例说明。

让我们举一个 printf 函数的例子来看看这些表是如何工作的。在我们的 main 函数中，printf 函数的调用指令：

```
400556:    e8 a5 fe ff ff           callq   0x400400
```

这个 call 指令调用了一个 **.plt** 段中的地址。看看这个段：

<script src="https://gist.github.com/kishuagarwal/b3e8029ce7c119ab655cd404d50d891b.js"></script>

每个外部定义的函数都在 **.plt** 段中，并且看起来都很像，都有 3 条指令。除了第一条有点例外，这个特殊的条目我们后面再看它的用处。

这里我们发现有一个到地址 **0x601018** 的跳转。这个地址是 GOT 表的一个条目。让我们看看这个地址的内容：

<script src="https://gist.github.com/kishuagarwal/3b30740bb5d9d4dcdec10a60a0fbf45a.js"></script>

这就是神奇的地方。除了第一次调用 printf 函数，此地址的值是 C 库的 printf 函数的真实地址，我们只需跳转到该位置即可。但第一次就不一样了。

当第一次调用 printf 函数时，此位置的值是 printf 函数的 **plt** 条目中下一条指令的地址。从上面的列表中看，它是 **400406**，以小端存储。在 **plt** 条目的这个位置有一个 push 指令，它将 0 压入堆栈。每个 **plt** 条目都有相同的压栈指令，但它们压入的数字不同。这里的 0 表示重定位表中 printf 符号的偏移量。然后，push 指令后跟 jump 指令，jump 指令跳转到第一个 **plt** 条目中的第一条指令。

还记得上面我告诉你第一个条目比较特殊吧。这是因为这里会调用动态链接器来解析外部符号并重新定位它们。为此，我们跳转到 **got** 表中地址 **601010**中包含的地址。这些地址应包含处理重定位的动态链接器的地址。现在这些条目填充为 0，但是当程序实际运行并且内核调用动态链接器时，链接器会填充此地址。

调用例程时，链接器将从外部共享目标文件解析之前压入栈的符号（在我们的示例中为 0），并将符号的正确地址放在 **got** 表中。所以，从现在开始，当调用 printf 函数时，我们不用参照阅链接器，我们可以直接从 plt 跳转到 C 库中的 printf 函数。

此过程称为延迟加载。程序可能包含许多外部符号，但在程序的一次运行中可能不会调用它们。因此，符号解析延迟到实际使用时，这节省了程序启动时间。

从上面的讨论中可以看出，我们从来没有必要修改 **plt** 段，而只修改了 **got** 段。这就是为什么 **plt** 段位于第一个 **LOAD** segment 并只标记为 R，而 **got** 段位于第二个 **LOAD** segment 并标记为 RW。

这就是动态链接器的工作原理。我已经跳过了很多“血腥”的细节，但如果你有兴趣了解更多细节，那么你可以查看[这篇文章](https://www.akkadia.org/drepper/dsohowto.pdf)。

让我们回到我们的程序加载。我们已经完成了大部分工作。内核已加载所有可加载的段，已调用动态链接器。剩下的就是调用我们的 main 函数。这在链接器完成后由链接器调用。当它调用我们的 main 函数时，我们在终端中得到以下输出：

```
3
```

我的朋友，祝福。

感谢你阅读我的文章。如果你喜欢我的文章或任何其他建议，请在下面的评论部分告诉我。请随便分享:)

---

本文翻译自 [kishuagarwal](https://kishuagarwal.github.io) 发表于其博客的文章 [Life of a binary](https://kishuagarwal.github.io/life-of-a-binary.html)。
